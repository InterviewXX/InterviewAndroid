# TCP

## 三次握手
- 客户端发送SYN报文段，SYN=1,seq=client_start_seq，进入 SYN_SENT 状态
- 服务端接收报文段，发送SYNACK报文段，SYN=1，ACK=client_start_seq+1,seq=server_start_seq,进入 SYN_REVD 状态
- 客户端接收SYNACK报文，发送一个报文段，SYN=0,ACK=sever_start_seq+1,可能会捎带数据，进入Established状态
- 服务端收到报文后，进入Establish状态

## 四次挥手
- 客户端发送FIN报文段，FIN=1，进入FIN_WAIT_1状态
- 服务端发送ACK，进入 CLOSE_WAIT状态
- 客户端接收ACK 进入 FIN_WAIT_2 状态
- 服务端发送FIN 报文段，进入LAST_ACK 状态
- 客户端接收FIN报文段，发送ACK，进入TIMED_WAIT ，一段时间后关闭连接
- 服务端接收ACK后，关闭连接

## 流量控制 
接收方和发送方维护对应状态，保证 lastSent-lastAcked<=lastRevd-lastRead=revWindow

## 拥塞控制

### 如何控制发送方
维护拥塞窗口变量CongWin,保证 lastSent-lastAcked<=min(CongWin,revWindow)

### 如何检测拥塞
超时或者三次冗余ACK 

### 避免拥塞策略
- 加性增，乘性减:遇见丢包后CongWin减半，以后每收到一个ACk，增加一个MSS
- 慢启动：CongWin 初始值为MSS(最大报文段长，有链路层帧长度确定)，每过一个RTT翻倍，知道遇见丢包事件
- 对超时事件作出响应：超时后直接进入慢启动，三次冗余CongWin减半

# 相关问题
## TCP 和 UDP 的区别？
TCP 提供可靠传输，面向连接；UDP 不可靠，不建立连接

## 谈谈TCP为什么要三次握手？
如果一次或者两次挥手就算有效，那么可以轻易制造SYN洪泛导致的DDOS攻击。另外如果没有最后一次挥手，在网络拥堵时，无法保证客户端在服务端接发出ACK后还有效，容易导致资源浪费。
再多次的握手没有意义。

## 为什么要四次挥手？ 

关闭连接需要确保双方都没有数据要传输了。前两次回收确保服务端知道了客户端关闭的意愿，但此时服务端可能还有数据要传输，所以需要在单独挥一次，但如果只挥一次，没发保证客户端知道了服务端关闭意愿，因此还需要客户端发一次ACK。

## 为什么四次挥手后客户端还要进入TIMED_WAIT？
如有必要则对ACK报文进行重传，避免报文段丢失。

## 拥塞控制和流量控制都是什么，两者的区别？
流量控制是为了平衡发送方的发送速率和接收方的读取速率，防止接收方缓存溢出；拥塞控制是为了避免整个网络链路过度拥堵，丢包率增加。

## 拥塞控制为什么对超时和三次冗余操作不同
三次冗余ACK代表虽然有丢包，但是网络状态还可以交付报文，而超时则意味着网络拥堵十分严重。

