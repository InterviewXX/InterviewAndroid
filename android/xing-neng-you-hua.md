# 性能优化



### 包体积优化？

可以使用lint工具，检测出没有用的文件。同时可以开启资源压缩（Proguard）,自动删除无用的资源。尽量多使用可绘制对象，某些图像不需要静态图像资源，框架可以在运行时动态绘制图像。尽量自己写Drawable，能不用UI切图就不用，占用空间小。

重用资源，比如一个三角按钮,点击前三角朝上代表收起的意思，点击后三角朝下，代表展开，一般情况下,我们会用两张图来切换，我们其实完全可以用旋转的形式去改变。比如同一图像的着色不同,我们可以用android:tint和tintMode属性，低版本可以使用ColorFilter。

压缩PNG和JPEG文件，可以减少PNG文件的大小，而不会丢失图像质量。使用WebP文件格式，可以使用WebP文件格式，而不是使用PNG或JPEG文件。可以使用AS将现有的BMP、JPG、PNG或静态GIF图像转换成WebP格式。使用矢量图形.svg；代码混淆，使用proGuard代码混淆器工具,它包括压缩，优化，混淆等功能。这个大家太熟悉。插件化，将功能模块放服务器上，按需下载，可以减少安装包大小。

### 启动优化？

利用提前展示出来的Window，快速展示出来一个节目，给用户快速反馈的体验。障眼法，治标不治本。

避免在启动时做密集沉重的初始化\(Heavy app initialization\)。某些SDK初始化放在异步去加载\(比如友盟，bugly这样的业务非必要可以异步加载\)，比如地图，推送等，非第一时间需要的可以在主线程做延时启动\(比如闪屏页\)，当程序已经启动起来之后,再进行初始化。对于网络，图片请求框架就必须在主线程中初始化了。

启动时，避免I/O操作，反序列化，网络操作，布局嵌套等耗时操作。

### 布局优化？

* 如果父控件有颜色，也是自己需要的颜色，那么就不必在子控件加背景颜色
* 如果子控件有背景颜色，并且能完全覆盖父控件，那么父控件不用设置背景颜色
* 尽量减少不必要的嵌套
* 能用LinearLayout和FrameLayout，就不要用RelativeLayout，因为RelativeLayout相对比较复杂，测绘也相对耗时。
* include和merge一起使用，增加复用，减少层级
* ViewStub按需加载，更加轻便
* 复杂界面选择ConstraintLayout，可有效减少层级

### 内存优化？

* 频繁使用字符串拼接用StringBuilder或者StringBuffer；ArrayMap、SparseArray替换HashMap；避免内存泄漏。
* 集合类泄漏\(集合一直引用着被添加进来的元素对象\)
* 单例/静态变量造成的内存泄漏\(生命周期长的持有了生命周期短的引用\)
* 匿名内部类/非静态内部类
* 资源未关闭造成的内存泄漏
* 检测内存泄漏的几个工具: LeakCanary，TraceView，Systrace，Android Lint和Memory Monitor+mat

### 内存泄漏

* 集合类泄漏\(集合一直引用着被添加进来的元素对象\)
* 单例/静态变量造成的内存泄漏\(生命周期长的持有了生命周期短的引用\)
* 匿名内部类/非静态内部类
* 资源未关闭造成的内存泄漏
* 网络，文件等流忘记关闭
* 手动注册广播时，退出时忘记unregisterReceiver\(\)
* Service执行完成后忘记stopSelf\(\)
* EventBus等观察者模式的框架忘记手动解除注册

### App 线程优化？

线程池避免存在大量的Thread，重用线程池内部的线程，从而避免了线程的创建和销毁带来的性能开销，同时能有效控制线程池的最大并发数，避免大量线程因互相抢占系统资源而导致阻塞线现象发生。推荐阅读《Android开发艺术探索》 第11章。

**分类**

* FixedThreadPool 数量固定的线程池
* CachedThreadPool 只有非核心线程，数量不定，空闲线程有超时机制，比较适合执行大量耗时较少的任务
* ScheduledThreadPool 核心线程数量固定，非核心线程没有限制。主要用于执行定时任务和具有固定中周期的重复任务。
* SingleThreadPool 只有一个核心线程，确保所有的任务在同一个线程顺序执行，统一外界任务到一个线程中，这使得在这些任务之间不需要处理线程同步的问题。

**优点**

* 减少在创建和销毁线程上所花的时间以及系统资源的开销
* 不使用线程池有可能造成系统创建大量的线程而导致消耗完系统内存以及"过度切换"

**注意点**

* 如果线程池中的数量未达到核心线程的数量,则直接启动一个核心线程来执行任务
* 如果线程池中的数量已经达到或超过核心线程的数量,则任何会被插入到任务队列中等待执行
* 如果2中的任务无法插入到任务队列中,由于任务队列已满,这时候如果线程数量未达到线程池规定的最大值,则会启动一个非核心线程来执行任务
* 如果3中的线程数量已经达到线程池最大值,则会拒绝执行此任务,ThreadPoolExecutor会调用RejectedExecutionHandler的rejectedExecution\(\)方法通知调用者
* * Q：项目中如何做性能优化的？
  * Q：了解哪些性能优化的工具？
  * Q：布局上如何优化？列表呢？
  * Q：内存泄漏是什么？为什么会发生？常见哪些内存泄漏的例子？都是怎么解决的？
  * Q：内存泄漏和内存溢出的区别？
  * Q：什么情况会导致内存溢出？

