# HotSpot 对象

## 对象的创建

1. new 指令
2. 2. 检查指令参数能否在常量池中定位到一个类的符号引用
3. 检查符号引用对应的类是否已经加载、解析和初始化过（如果没有需先进行类加载过程）
4. 虚拟机为新生对象分配内存（内存大小在类加载完成后便可以确定）
5. 将内存空间初始化为零值
6. 对对象进行必要配置\(属于哪个类的实例、对象的哈希码、对象的GC分代年龄，这些信息存放在对象头\(Object Header\)中\)
7. 执行对象的构造方法&lt;init&gt;

### 为对象分配空间

为对象分配空间的任务等同于把一块大小确定的内存从 Java 堆中划分出来。

假设 Java 堆中的内存时绝对规整的，用过的内存放在一边，未用过的内存 放在另一边，中间存放着一个指针作为分界点的指示器，则分配内存就是把指针往空闲的一侧移动与对象大小相等的距离，这种分配方式成为「**指针碰撞**」\(Bump the pointer\)。

如果 Java 堆中内存不是规整的，已使用的内存和未使用的内存相互交错，那就没有办法应用指针碰撞了，虚拟机必须维护一个列表，记录哪些内存块是可用的，当分配空间时，找一块足够大的空间分配给内存实例，并更新列表上的记录，这种分配方式成为「**空闲链表**」\(Free List\)。

选择哪种分配方式由Java堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

### 如何保证内存分配的线程安全

对象创建在虚拟机中是非常频繁的行为，即使是修改一个指针所指向的位置，在并发情况下也不是线程安全的，可能出现正在给对象 A 分配内存，指针还没来得及移动，对象 B 又使用原来的指针分配内存的情况。

解决方案：

* 对分配内存空间的动作进行同步处理——虚拟机采用CAS和失败重试保证更新操作的原子性
* 把内存分配的动作按照线程划分在不同的空间中进行，每个线程预先在堆中分配一小块内存，成为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），线程的内存分配在自己的 TLAB 上进行，只有TLAB用完并分配新的 TLAB 时，才需要同步锁定。虚拟机是否使用TLAB，可以通过 -XX:+/-UseTLAB 来配置

