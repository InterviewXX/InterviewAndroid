# 类及其加载机制

## Class 类文件结构

> 类或接口不一定定义在文件中，也可以由类加载器生成。

class 文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在 class 文件中，中间没有添加任何分隔符。对于占用8位字节以上的数据，则按照高位在前\(地址低位\)的方式分割成多个字节存储。

根据 Java 虚拟机规范，class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据，这种结构只包含两种数据：**无符号数和表**。

* 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别表示1、2、4、8个字节的无符号数，可以用来描述数字、符号引用、数量值或者按照UTF-8编码构成字符串值。
* 表是由多个无符号数或者其他表组成的复合数据类型，所有的表都以"\_info"结尾，表用于描述有层次关系的复合结构的数据，整个class文件本质上就是一张表。

![class &#x6587;&#x4EF6;&#x683C;&#x5F0F;](../../.gitbook/assets/image%20%2822%29.png)

无论是无符号数还是表，当需要描述同一类型但是数量不定的多个数据时，经常会使用一个前置的容量计数器加若干连续数据项表示，这时称这些连续的数据为某一类型的集合。

### 魔数\(Magic Number\)

每个 class 文件的前4个字节成为魔数，它的唯一作用就是确定这个文件是否为一个能被虚拟机接收的 class 文件。

class 文件的魔数是为：`0xCAFEBABE`

### class 文件版本

class 文件的第5、6个字节为次版本号\(minor version\)，第7、8个字节为主版本号\(major version\)。Java 的版本号从 45 开始，每发布一个大版本就加1。高版本的 JDK 能向下兼容低版本的class文件，但不能运行更高版本的class，虚拟机必须拒绝执行高于其版本号的class文件。

![class &#x6587;&#x4EF6;&#x7248;&#x672C;&#x53F7;](../../.gitbook/assets/image%20%2829%29.png)

### 常量池

常量池可以理解为 class 的资源仓库，它是class文件文件结构中与其他项目关联最多的数据类型，也是占用class 文件空间最大的数据项目之一。

由于常量池中常量的数量不是固定的，因此需要在常量池的入口放置一个u2类型的数据代表常量池容量计数值\(constant\_pool\_count\)，这个容器计数从1开始而不是从0开始。如果常量池中有10个常量，那么该值为11（索引范围为1-10）。

常量池中主要存放两大类常量：

* **字面量：文本字符串、final 常量值等**
* **符号引用**
  * 类和接口的全限定名
  * 字段的名称和描述符
  * 方法的名称和描述符

> Java 代码在进行 javac 编译时，并不像c/c++那样有「连接」这一步，而是在虚拟机加载class文件时进行动态连接。也就是说 class文件不会保存方法、字段的内存布局信息，因此这些字段、方法的符号引用不经过运行期转换无法获得真正的内存地址入口，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获取对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中。

常量池的每一个常量都是一个表，JDK 1.7 开始已经有14种不同类型的表结构。这些表结构的共同点是开始的第一位是一个u1类型的标志位\(tag\)，代表当前这个常量属于哪种类型。

![&#x5E38;&#x91CF;&#x6C60;&#x4E2D;&#x5E38;&#x91CF;&#x7684;&#x7C7B;&#x578B;](../../.gitbook/assets/image%20%2837%29.png)

![14 &#x4E2D;&#x5E38;&#x91CF;&#x7C7B;&#x578B;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;](../../.gitbook/assets/image%20%282%29.png)

![14 &#x4E2D;&#x5E38;&#x91CF;&#x7C7B;&#x578B;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;](../../.gitbook/assets/image%20%286%29.png)

### 访问标识

常量池后的两个字节代表访问标识\(access\_flag\)，用于识别类或接口层次的访问信息，包括：这个class 是类还是接口、是否定义为public、是否定义为 abstract、是否定义为 final 。

![&#x8BBF;&#x95EE;&#x6807;&#x8BC6;](../../.gitbook/assets/image%20%2838%29.png)

### 类索引、父类索引与接口索引集合

类索引、父类索引和接口索引按顺序排在访问标识后，

类索引\(this\_class\)与父类索引\(super\_class\)都是一个 u2 类型的数据，而接口索引集合是一组u2类型的数据的集合，class 文件由这三项数据确定类的继承关系。

类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，接口索引集合确定这个类实现了哪些接口，实现接口按照implements语句的顺序从左到右排列。

类索引和父类索引指向一个类型为CONSTANT\_Class\_info的类描述符常量，对于接口集合，入口的第一项u2类型的数据为接口计数器，表示索引表的容量，剩下的为u2类型的数据，指向类描述常量。

### 字段表集合\(field\_info\)

字段表用于描述类或接口中声明的变量，字段包括类级变量和实际级变量，但不包括方法内部声明的局部变量。字段表结构如下表：

| 类型 | 名称 | 数量 |
| :---: | :---: | :---: |
| u2 | access\_flag | 1 |
| u2 | name\_index | 1 |
| u2 | descriptor\_index | 1 |
| u2 | attributes\_count | 1 |
| attribute\_info | attributes | attributes\_count |

字段修饰符放在 `access_flags` 项目中，其可以设置的标识位如下表所示：

| 标志名称 | 标志值 | 含义 |
| :---: | :---: | :---: |
| ACC\_PUBLIC | 0x0001 | 是否 public |
| ACC\_PRIVATE | 0x0002 | 是否 private |
| ACC\_PROTECTED | 0x0004 | 是否 protected |
| ACC\_STATIC | 0x0008 | 是否 static |
| ACC\_FINAL | 0x0010 | 是否 final |
| ACC\_VOLATILE | 0x0040 | 是否 volatile |
| ACC\_TRANSIENT | 0x0080 | 是否 transient |
| ACC\_SYNTHETIC | 0x1000 | 是否由编译器自动生成 |
| ACC\_ENUM | 0x4000 | 是否是枚举 |

name\_index 和 descriptor\_index 是对常量的引用，分别代表字段的**简单名称**以及字段和方法的**描述符**。

#### 全限定名称、简单名称和描述符

* 全限定名称：org/test/class/TestClass
* 简单名称：没有类型或参数修饰的方法或字段名称，`int m;` 其中 m 的简单名称是"m".
* 描述符：描述字段的数据类型、方法的参数列表和返回值。根据描述符规则，基本数据类型以及代表无返回值的void类型都用一个大写字母来表示，而对象类型则用字符L加对象的全限定名表示，如下表：

| 标识字符 | 含义 |
| :---: | :---: |
| B | 基本类型 byte |
| C | 基本类型 char |
| D | 基本类型 double |
| F | 基本类型 float |
| I | 基本类型 int |
| J | 基本类型 long |
| S | 基本类型 short |
| Z | 基本类型 boolean |
| V | 特殊类型 void |
| L | 对象类型，如Ljava/lang/Object |

对于数组类型，每个维度使用一个前置的"\["来描述，如定义为"java.lang.String\[\]\[\]"的二维数组，将被记录为"\[\[Ljava/lang/String;"。

用描述符描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号内。如方法"inc\(\)"的描述符为"\(\)V"，方法"int add\(int a,int b\)"的表述符为"\(II\)I"。

字段表集合中不会列出从超类或者父接口中继承的字段，但有可能列出原本java代码中不包含的字段，比如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。

### 方法表集合

方法表集合与字段表集合结构相同，而由于 volatile 和 transient 不能修饰方法，所以方法表的访问标志中没有 ACC\_VOLATILE 和 ACC\_TRANSIENT，而增加了ACC\_SYNCHRONIZED、ACC\_NATIVE、ACC\_STRICTFP和ACC\_ABSTRACT。方法表的标志位取值见下表：

| 标志名称 | 标志值 | 含义 |
| :--- | :--- | :--- |
| ACC\_PUBLIC | 0x0001 | 是否 public |
| ACC\_PRIVATE | 0x0002 | 是否 private |
| ACC\_PROTECTED | 0x0004 | 是否 protected |
| ACC\_STATIC | 0x0008 | 是否 static |
| ACC\_FINAL | 0x0010 | 是否 final |
| ACC\_SYNCHRONIZED | 0x0020 | 是否 synchronized |
| ACC\_BRIDGE | 0x0040 | 是否是编译器产生的桥接方法 |
| ACC\_VARARGS | 0x0080 | 是否接受可变参数 |
| ACC\_NATIVE | 0x0100 | 是否 native |
| ACC\_ABSTRACT | 0x0400 | 是否 abstract |
| ACC\_STRICTFP | 0x0800 | 是否 strictfp |
| ACC\_SYNTHETIC | 0x1000 | 是否由编译器自动生成 |

> 方法的代码经过编译成字节码指令后，存放在方法属性表集合中一个名为"Code"的属性里。

如果父类方法没有在子类中被重写\(override\)，那么方法表集合中不会出现父类的方法，但可能出现有编译器添加的方法，例如类构造器"&lt;clinit&gt;"和实例构造器"&lt;init&gt;"。

在 Java 语言中，要重载一个方法，除了要与原方法具有相同的简单名称之外，还要求必有有一个与原方法不同的特征签名，特征签名就是一个方法中年各个参数在常量池中的字段符合引用的集合，即**返回值不包含在特征签名里，因此Java中不能以返回值不同而对方法进行重载**。但在 class 文件格式中，特征签名的范围更大，只要描述符不完全一致的两个方法都可以共存，也就是说，如果两个方法具有相同的名称和特征签名\(java语言层面\)，但是返回值不同，是可以合法共存于一个class文件中。

> **Java 代码层面的方法特征签名包含方法名称、参数顺序和参数类型，而字节码层面的方法特征签名还包括返回值和受检异常表。**

### 属性表\(attribute\_info\)

属性表用于描述某些场景专有的信息，在 Class文件、字段表、方法表都可以携带自己的属性表集合。属性表集合的限制比较宽松，不要求各个属性表有严格顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己的属性信息，Java 虚拟机在运行时会忽略掉它不认识的属性。

Java 虚拟机规范（SE 7）中预定义的属性如下表：

![](../../.gitbook/assets/image%20%2830%29.png)

![](../../.gitbook/assets/image%20%2846%29.png)

属性表结构：

![](../../.gitbook/assets/image%20%2813%29.png)









## 类加载过程

![](../../.gitbook/assets/jie-ping-2019121122.24.23.png)

#### 加载

1. 通过类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流代表的静态存储结构转化方法区的运行时数据结构
3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口

#### 验证

连接的第一步，目的是确保Class文件字节流中包含的信息符合当前虚拟机要求，并且不会危害 虚拟机自身的安全。

* 文件格式验正
* 元数据验正
* 字节码验证
* 符号引用 验证

#### 准备

正式为类变量分配内存并设置变量初始值的阶段，这些变量使用的初始值都将在方法区分配。进行内存分配的是类变量而不是实例变量，会赋值为初始值。只有被final修饰的常量才会被赋成设定的值。

#### 解析

将常量池中的符号引用替换为直接引用过程。

* 类或接口解析
* 字段解析
* 类方法解析
* 接口方法解析

#### 初始化 

真正开始执行类中定义的 Java 程序代码，根据程序员制定的主观计划去初始化类变量和其他资源。

## 类加载器的Parents Delegation 模型（TODO）

![](../../.gitbook/assets/jie-ping-2019121122.42.48.png)

双亲委派模型除了顶层的启动类加载器外，所有的类加载器都有自己的父类加载器。

工作过程：类加载器收到类加载请求后，首先会委派给父类加载器进行加载，每一层都是如此，最终类加载请求会传给顶层的启动类加载器。只有当父类加载器无法完成加载请求时，子类加载器才会尝试自己去加载。

使用双亲委派模型组织类加载器，**使得类同加载器一起具备带有优先级的层次关系。例如java.lang.Object 只会委派给启动类加载器进行加载，防止出现多份同样的字节码以及核心类被篡改。**

