---
description: 关于 Java 虚拟机(Java Virtual Machine)的知识要点
---

# JVM

### JVM 内存是如何划分的？

![](../.gitbook/assets/jie-ping-2019120922.23.17.png)

#### 程序计数器（Program Counter Register ）

一块较小的内存区域，可以看做是当前线程执行字节码的行号指示器。字节码解释器就是通过 改变这个计数器的值来决定下一条要读取的字节码指令。分支、循环、异常处理都需要依赖它完成。

为了满足线程切换的需求，这块区域是**线程私有**的。

如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的字节码指令地址；而如果执行的是 Native 方法 ，这个计数器的值为空\(Undefined\)。

此内存区域是Java虚拟机规范中唯一一个没有规定任何 OutOfMemeoryError 的区域。

#### Java 虚拟机栈（JVM Stacks）

线程私有的内存区域，生命周期与线程相同。

虚拟机栈描述了Java 方法执行的内存模型：每个方法执行时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息；而一个方法从开始执行到执行完成的过程，就对应了一个栈帧的入栈和出栈。

局部变量表存放了编译期可知的各种基本数据类型、数据引用类型，它不等同于对象本身，而可能是指向对象起始地址的引用指针、也可能指向代表对象的句柄或一条字节码指令的地址\(returnAddress类型\)。

64位长度的long 和 double 类型会占据两个局部变量空间\(slot\)，其余的数据类型只占用一个。局部变量表所占空间在编译期完成分配，当进入一个方法时，该方法需要在栈中分配的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

在 Java 虚拟机规范中，对虚拟机栈规定了两种异常情况：

* 如果线程请求的栈深度大于虚拟机允许的最大深度，将抛出StackOverflowError
* 如果虚拟机栈可以动态扩展，但是扩展式无法申请到足够的内存，则抛出OutOfMemoryError

#### 本地方法栈（Native Method Stack）

与Java 虚拟机栈作用类似，区别主要自安于本地方法栈为Native方法服务，而虚拟机栈为 Java 方法服务。

与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError。

#### Java 堆（Java Heap）

一块线程共享的区域，在虚拟机启动时创建，用于存放对象实例。Java 虚拟机规范规定所有的 对象和数组都要在堆上分配。

Java 堆是垃圾收集器管理的主要区域，可以处于不连续的内存空间，只要逻辑上连续即可。在实现时，既可以是固定大小的，又可以是可扩展的。

如果堆上没有足够内存完成对象分配，且不可扩展时，会抛出 OutOfMemoryError。

#### 方法区（Method Area）

也是线程共享的内存区域，用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

Java 虚拟机规范对方法区的限制非常宽松，除了像Java堆一样不使用连续内存空间和可以选择固定大小和可扩展外， 还可以选择不实现垃圾回收。对方法区的内存回收主要针对常量的回收和类型的卸载，但类型的卸载条件较为苛刻，因此在这个区域的垃圾回收可能效果不令人满意。但回收有时必要的，否则可能引发内存泄漏。

当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError。

#### 运行时常量池（Runtime Constant Pool）

方法区的一部分，Class 文件除了类的版本、字段、方法、接口等描述信息，还有常量池（Constant Pool Table），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池存放。

Java 虚拟机规范对运行时常量池没有做任何细节要求。

运行时常量池相对于Class文件的常量池的一个重要特性就是动态性，Java 语言并没有规定常量只能在编译期产生，运行期间也可以将新的常量放入池中，例如 String 的 intern\(\) 方法。

运行时常量池收方法区内存限制，无法再申请到内存时将抛出 OutOfMemoryError。

#### 直接内存（Direct Memory）

不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。

JDK 1.4 加入了 NIO 类，引入了一种基于通道（Channel）和缓冲区\(Buffer\)的IO方式，它可以使用native方法 直接申请堆外内存，然后通过一个存储在堆中的 DirectByteBuffer 对象作为这块内存的引用来对其进行操作。这样避免了在 Java堆和native堆中的数据复制，能显著提高性能。

直接内存不收Java堆大小限制，但会受内存大小和CPU 寻址空间限制，内存不足时抛出 OutOfMemoryError。

### 谈谈垃圾回收机制？

### 知道哪些垃圾回收算法？

### 为什么引用计数器判定对象是否回收不可行？

引用计数器方法无法 解决循环 引用的问题。

### Java中引用有几种类型？在Android中常用于什么情景？

* 强引用，默认就是，宁愿OOM，也不回收
* 弱引用，内存不够会被回收
* 软引用，GC时会被回收
* 虚引用，它的作用在于跟踪垃圾回收过程，在对象被收集器回收时收到一个系统通知

### 类加载的全过程是怎样的？什么是双亲委派模型？

### 工作内存和主内存的关系？在Java内存模型有哪些可以保证并发过程的原子性、可见性和有序性的措施？

### JVM、Dalvik、ART的区别？

### Java中堆和栈的区别？

